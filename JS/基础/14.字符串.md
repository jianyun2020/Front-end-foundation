字符串的内部格式始终是 UTF-16，它不依赖于页面编码。

# 字符串长度

`length`属性表示字符串长度：

```js
alert( `My\n`.length ); // 3
```

注意 `\n` 是一个单独的“特殊”字符，所以长度确实是 3。

> length 是一个属性
> 掌握其他编程语言的人，有时会错误地调用 str.length() 而不是 str.length。这是行不通的。
> 请注意 str.length 是一个数字属性，而不是函数。后面不需要添加括号。

# 访问字符

要获取在 `pos` 位置的一个字符，可以使用方括号 `[pos]` 或者调用 `str.charAt(pos)` 方法。第一个字符从零位置开始：

```js
let str = `Hello`;

// 第一个字符
alert( str[0] ); // H
alert( str.chartAt(0) ); // H

// 最后一个字符
alert( str[str.length - 1] ); // o
```

方括号是获取字符的一种现代化方法，而 `charAt` 是历史原因才存在的。

它们之间的唯一区别是，如果没有找到字符，`[]` 返回 `undefined`，而 `charAt` 返回一个空字符串：

```js
let str = `Hello`;

alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // ''
```

我们也可以使用 `for..of` 遍历字符：

```js
for (let char of "Hello") {
    alert( char ); // H,e,l,l,o
}
```

# 字符串是不可变的

在 `JavaScript` 中，字符串不可更改。改变字符是不可能的。

```js
let str = 'Hi';

str[0] = 'h'; // error
alert( str[0] ); // 无法运行
```

通常的解决方法是创建一个新的字符串，并将其分配给 `str` 而不是以前的字符串。

```js
let str = 'Hi';

str = 'h' + str[1]; // 替换字符串

alert( str ); // hi
````

# 改变大小写

```js
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
```

或者我们想要使一个字符串变成小写：

```js
alert( 'Interface'[0].toLowerCase() ); // i
```

# 查找字符串

## `str.indexOf(substr, pos)`

它从给定位置 `pos` 开始，在 `str` 中查找 `substr`，如果没有找到，则返回 -1，否则返回匹配成功的位置。

```js
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0，因为'Widget'一开始就被找到
alert( str.indexOf('widget') ); // -1，没有找到，检索是大小写敏感
alert( str.indexOf("id") ); // 1，"id"在位置1处
```

可选的第二个参数允许我们从给定的起始位置开始检索。

例如，"id" 第一次出现的位置是 1。查询下一个存在位置时，我们从 2 开始检索：

```js
let str = 'Widget with id';

alert( str.indexOf('id', 2) ); // 12
```

如果我们对所有存在位置都感兴趣，可以在一个循环中使用 `indexOf`。每一次新的调用都发生在上一匹配位置之后：

```js
let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // 要查找的目标

let pos = 0;

while (true) {
    let foundPos = str.indexOf(target, pos);
    if (foundPos == -1) break;

    alert( `Found as ${foundPos}` );

    pos = foundPos + 1; // 继续从下一个位置查找
}
```

相同的算法可以简写：

```js
let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;

while ((pos = str.indexOf(target, pos + 1)) != -1) {
    alert( pos );
}
```

> `str.lastIndexOf(substr, pos)`，这个类似的方法从字符串末尾开始搜索到开头。它会以相反的顺序列出这些事件。

在 `if` 测试中 `indexOf` 有一点不方便。我们不能像这样把它放在 `if` 中：

```js
let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert( "We found it" ); // 不工作
}
```

上述示例中的 `alert` 不会显示，因为 `str.indexOf("Widget")` 返回 0（意思是它在起始位置就查找到了匹配项）。是的，但是 `if` 认为 0 表示 `false`。

因此我们应该检查 -1，像这样：

```js
let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("We found it"); // 现在工作了
}
```

## 按位(bitwise)NOT技巧

这里使用的一个老技巧是 bitwise NOT `~` 运算符。它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反。

实际上，这意味着一件很简单的事儿：对于 32-bit 整数，~n 等于 -(n+1)。

```js
alert( ~2 ); // -3，和 -(2+1) 相同
alert( ~1 ); // -2，和 -(1+1) 相同
alert( ~0 ); // -1，和 -(0+1) 相同
alert( ~-1 ); // 0，和 -(-1+1) 相同
```

正如我们看到这样，只有当 n == -1 时，~n 才为零（适用于任何 32-bit 带符号的整数 n）。

因此，仅当 indexOf 的结果不是 -1 时，检查 if ( ~str.indexOf("...") ) 才为真。换句话说，当有匹配时。

人们用它来简写 indexOf 检查：

```js
let str = "Widget";

if (~str.indexOf("Widget")) {
    alert( 'Found it!' ); // 正常运行
}
```

通常不建议以非显而易见的方式使用语言特性，但这种特殊技巧在旧代码中仍被广泛使用，所以我们应该理解它。

只要记住：`if (~str.indexOf(...))` 读作 “if found”。

确切地说，由于 ~ 运算符将大数字截断为 32 位，因此存在给出 0 的其他数字，最小的数字是 ~4294967295=0。这使得这种检查只有在字符串没有那么长的情况下才是正确的。

现在我们只会在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 `.includes` 方法（见下文）。

## `includes, startsWith, endsWith`

更现代的方法 `str.includes(substr, pos)` 根据 `str` 中是否包含 `substr` 来返回 `true/false`。

如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择：

```js
alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
```

`str.includes` 的第二个可选参数是开始搜索的起始位置：

```js
alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, 从位置 3 开始没有 "id"
```

方法 `str.startsWith` 和 `str.endsWith` 的功能与其名称所表示的意思相同：

```js
alert( "Widget".startsWith("Wid") ); // true，"Widget" 以 "Wid" 开始
alert( "Widget".endsWith("get") ); // true，"Widget" 以 "get" 结束
```

# 获取字符串

JavaScript 中有三种获取字符串的方法：`substring`、`substr` 和 `slice`。

## str.slice(start [, end])

返回字符串从 start 到（但不包括）end 的部分。

```js
let str = "stringify";
alert( str.slice(0, 5) ); // 'strin'，从 0 到 5 的子字符串（不包括 5）
alert( str.slice(0, 1) ); // 's'，从 0 到 1，但不包括 1，所以只有在 0 处的字符
```

如果没有第二个参数，slice 会一直运行到字符串末尾：

```js
let str = "stringify";
alert( str.slice(2) ); // 从第二个位置直到结束
```

start/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算：

```js
let str = "stringify";

// 从右边的第四个位置开始，在右边的第一个位置结束
alert( str.slice(-4, -1) ); // 'gif'
```

## str.substring(start [, end])

返回字符串在 `start` 和 `end` 之间 的部分。

这与 `slice` 几乎相同，但它允许 `start` 大于 `end`。

```js
let str = "stringify";

// 这些对于 substring 是相同的
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// ……但对 slice 是不同的：
alert( str.slice(2, 6) ); // "ring"（一样）
alert( str.slice(6, 2) ); // ""（空字符串）
```

不支持负参数（不像 slice），它们被视为 0。

## str.substr(start [, length])

返回字符串从 start 开始的给定 length 的部分。

与以前的方法相比，这个允许我们指定 `length` 而不是结束位置：

```js
let str = "stringify";
alert( str.substr(2, 4) ); // 'ring'，从位置 2 开始，获取 4 个字符
```

第一个参数可能是负数，从结尾算起：

```js
let str = "stringify";
alert( str.substr(-4, 2) ); // 'gi'，从第 4 位获取 2 个字符
```

我们回顾一下这些方法，以免混淆：

|方法|选择方式|负值参数|
|-|-|-|
|`slice(start, end)`|从`start`到`end`（不含`end`）|允许|
|`substring(start, end)`|从`start`到`end`（不含`end`）|	负值代表 `0`|
|`substr(start, length)`|从 `start` 开始获取长为 `length` 的字符串|允许 `start` 为负数|

> 使用哪一个？
> 它们可以完成这项工作。形式上，`substr` 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中，它涵盖了主要由于历史原因而存在的仅浏览器特性。因此，非浏览器环境可能无法支持它。但实际上它在任何地方都有效。
>
> 相较于其他两个变体，`slice` 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 `slice` 就足够了。

# 比较字符串

